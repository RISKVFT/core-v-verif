# ** Warning: License feature 'msimviewer' will expire in 10 days.
# vsim gold.wlf 
# Start time: 18:46:13 on Nov 20,2020
# ** Error (suppressible): (vsim-19) Failed to access library 'gold' at "gold".
# No such file or directory. (errno = ENOENT)
# Error loading design
# End time: 18:46:13 on Nov 20,2020, Elapsed time: 0:00:00
# Errors: 1, Warnings: 0
load gold.wlf
# couldn't load file "gold.wlf": gold.wlf: cannot open shared object file: No such file or directory
ls
# bench_log
# ccommon.sh
# change_word.sh
# compile
# comp_sim.sh
# cv32e40p_temp_manifest.flist
# error_log.txt
# error_monitor.txt
# Makefile
# README.md
# sim_FT
# trace_command.txt
# transcript
# vsim2.wlf
load sim_FT/gold.wlf
# couldn't load file "sim_FT/gold.wlf": sim_FT/gold.wlf: invalid ELF header
man load
# load(n)                      Tcl Built-In Commands                     load(n)
# 
# 
# 
# ______________________________________________________________________________
# 
# NAME
#        load - Load machine code and initialize new commands
# 
# SYNOPSIS
#        load fileName
#        load fileName packageName
#        load fileName packageName interp
# _________________________________________________________________
# 
# 
# DESCRIPTION
#        This  command  loads  binary  code  from  a file into the application's
#        address space and calls an initialization procedure in the  package  to
#        incorporate  it  into an interpreter.  fileName is the name of the file
#        containing the code;  its exact form varies from system to  system  but
#        on  most  systems  it  is  a  shared  library, such as a .so file under
#        Solaris or a DLL under Windows.  packageName is the name of  the  pack‐
#        age,  and  is  used to compute the name of an initialization procedure.
#        interp is the path name of the interpreter into which to load the pack‐
#        age (see the interp manual entry for details); if interp is omitted, it
#        defaults to the interpreter in which the load command was invoked.
# 
#        Once the file has been loaded into the application's address space, one
#        of two initialization procedures will be invoked in the new code.  Typ‐
#        ically the initialization procedure will add  new  commands  to  a  Tcl
#        interpreter.  The name of the initialization procedure is determined by
#        packageName and whether or not the target interpreter is  a  safe  one.
#        For  normal  interpreters the name of the initialization procedure will
#        have the form pkg_Init, where pkg is the  same  as  packageName  except
#        that  the first letter is converted to upper case and all other letters
#        are converted to lower case.  For example, if  packageName  is  foo  or
#        FOo, the initialization procedure's name will be Foo_Init.
# 
#        If  the  target interpreter is a safe interpreter, then the name of the
#        initialization procedure will be pkg_SafeInit instead of pkg_Init.  The
#        pkg_SafeInit  function should be written carefully, so that it initial‐
#        izes the safe interpreter only with partial functionality  provided  by
#        the  package  that is safe for use by untrusted code. For more informa‐
#        tion on Safe-Tcl, see the safe manual entry.
# 
#        The initialization procedure must match the following prototype:
#               typedef int Tcl_PackageInitProc(Tcl_Interp *interp);
#        The interp argument identifies the interpreter in which the package  is
#        to  be  loaded.   The  initialization  procedure  must return TCL_OK or
#        TCL_ERROR to indicate whether or not it completed successfully;  in the
#        event of an error it should set the interpreter's result to point to an
#        error message.  The result of the  load  command  will  be  the  result
#        returned by the initialization procedure.
# 
#        The  actual  loading of a file will only be done once for each fileName
#        in an application.  If a given fileName is loaded into multiple  inter‐
#        preters,  then  the first load will load the code and call the initial‐
#        ization procedure;  subsequent loads will call the initialization  pro‐
#        cedure  without  loading  the  code again.  For Tcl versions lower than │
#        8.5, it is not possible to unload or reload a package. From version 8.5 │
#        however,  the  unload  command allows the unloading of libraries loaded │
#        with load, for libraries that are aware of the Tcl's  unloading  mecha‐ │
#        nism.
# 
#        The load command also supports packages that are statically linked with
#        the application, if those packages have been registered by calling  the
#        Tcl_StaticPackage  procedure.   If  fileName  is  an empty string, then
#        packageName must be specified.
# 
#        If packageName is omitted or specified as an empty string, Tcl tries to
#        guess the name of the package.  This may be done differently on differ‐
#        ent platforms.  The default guess, which is used  on  most  UNIX  plat‐
#        forms,  is  to  take  the last element of fileName, strip off the first
#        three characters if they are lib, and use any following alphabetic  and
#        underline characters as the module name.  For example, the command load
#        libxyz4.2.so uses the module name xyz and the command load  bin/last.so
#        {} uses the module name last.
# 
#        If  fileName  is  an  empty string, then packageName must be specified.
#        The load command first searches for a statically  loaded  package  (one
#        that has been registered by calling the Tcl_StaticPackage procedure) by
#        that name; if one is found, it is used.  Otherwise,  the  load  command
#        searches  for a dynamically loaded package by that name, and uses it if
#        it is found.  If several different files have been loaded with  differ‐
#        ent versions of the package, Tcl picks the file that was loaded first.
# 
# PORTABILITY ISSUES
#        Windows
#               When  a  load  fails  with “library not found” error, it is also
#               possible that a dependent library was not  found.   To  see  the
#               dependent  libraries, type “dumpbin -imports <dllname>” in a DOS
#               console to see what the library must import.  When loading a DLL
#               in  the  current  directory,  Windows will ignore “./” as a path
#               specifier and use a search heuristic to find  the  DLL  instead.
#               To avoid this, load the DLL with:
#               load [file join [pwd] mylib.DLL]
# 
# BUGS
#        If  the  same  file is loaded by different fileNames, it will be loaded
#        into the process's address space multiple times.  The behavior of  this
#        varies  from  system  to  system (some systems may detect the redundant
#        loads, others may not).
# 
# EXAMPLE
#        The following is a minimal extension:
# 
#               #include <tcl.h>
#               #include <stdio.h>
#               static int fooCmd(ClientData clientData,
#                       Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
#                   printf("called with %d arguments\n", objc);
#                   return TCL_OK;
#               }
#               int Foo_Init(Tcl_Interp *interp) {
#                   if (Tcl_InitStubs(interp, "8.1", 0) == NULL) {
#                 return TCL_ERROR;
#                   }
#                   printf("creating foo command");
#                   Tcl_CreateObjCommand(interp, "foo", fooCmd, NULL, NULL);
#                   return TCL_OK;
#               }
# 
#        When built into a shared/dynamic library with  a  suitable  name  (e.g.
#        foo.dll  on  Windows,  libfoo.so  on  Solaris and Linux) it can then be
#        loaded into Tcl with the following:
# 
#               # Load the extension
#               switch $tcl_platform(platform) {
#                  windows {
#                     load [file join [pwd] foo.dll]
#                  }
#                  unix {
#                     load [file join [pwd] libfoo[info sharedlibextension]]
#                  }
#               }
# 
#               # Now execute the command defined by the extension
#               foo
# 
# 
# SEE ALSO
#        info sharedlibextension, Tcl_StaticPackage(3), safe(n)
# 
# 
# KEYWORDS
#        binary code, loading, safe interpreter, shared library
# 
# 
# 
# Tcl                                   7.5                              load(n)
open sim_FT/gold.wlf
# file16
man open
# OPENVT(1)                          Linux 1.x                         OPENVT(1)
# 
# 
# 
# NAME
#        openvt - start a program on a new virtual terminal (VT).
# 
# SYNOPSIS
#        openvt [-c vtnumber] [OPTIONS] [--] command
# 
# DESCRIPTION
#        openvt  will  find the first available VT, and run on it the given com‐
#        mand with the given command options, standard input, output  and  error
#        are  directed to that terminal. The current search path ($PATH) is used
#        to find the requested command. If no  command  is  specified  then  the
#        environment variable $SHELL is used.
# 
#    OPTIONS
#        -c, --console=VTNUMBER
#               Use  the  given  VT number and not the first available. Note you
#               must have write access to the supplied VT for this to work;
# 
#        -f, --force
#               Force opening a VT without checking whether  it  is  already  in
#               use;
# 
#        -e, --exec
#               Directly  execute  the  given  command,  without  forking.  This
#               option is meant for use in /etc/inittab;
# 
#        -s, --switch
#               Switch to the new VT when starting the command. The  VT  of  the
#               new command will be made the new current VT;
# 
#        -u, --user
#               Figure  out  the  owner of the current VT, and run login as that
#               user.  Suitable to be called by init. Shouldn't be used with  -c
#               or -l;
# 
#        -l, --login
#               Make  the command a login shell. A - is prepended to the name of
#               the command to be executed;
# 
#        -v, --verbose
#               Be a bit more verbose;
# 
#        -w, --wait
#               wait for command to complete. If -w and  -s  are  used  together
#               then  openvt  will  switch back to the controlling terminal when
#               the command completes;
# 
#        -V, --version
#               print program version and exit;
# 
#        -h, --help
#               show this text and exit.
# 
#        --     end of options to openvt.
# 
# NOTE
#        If openvt is compiled with a getopt_long() and you wish to set  options
#        to  the  command  to be run, then you must supply the end of options --
#        flag before the command.
# 
# EXAMPLES
#        openvt can be used to start a shell on the next free VT, by  using  the
#        command:
# 
#        openvt bash
# 
# 
#        To start the shell as a login shell, use:
# 
#        openvt -l bash
# 
# 
#        To get a long listing you must supply the -- separator:
# 
#        openvt -- ls -l
# 
# 
# 
# HISTORY
#        Earlier,  openvt  was  called  open.   It  was  written  by  Jon  Tombs
#        <jon@gtex02.us.es or jon@robots.ox.ac.uk>.  The -w idea is from "sam".
# 
# 
# SEE ALSO
#        chvt(1), doshell(8), login(1)
# 
# 
# 
# 19 Jul 1996                          V1.4                            OPENVT(1)
dataset open sim_FT/gold.wlf
# sim_FT/gold.wlf opened as dataset "gold1"
